/* tslint:disable */
/* eslint-disable */

/* auto-generated by NAPI-RS */

/** Result of an adaptive step. */
export interface AdaptiveStepResult {
  /** Whether a decision was reached. */
  isDecision: boolean
  /** Current leak probability estimate. */
  currentProbability: number
  /** Samples collected per class so far. */
  samplesPerClass: number
  /** The final result (only valid if is_decision is true). */
  result?: AnalysisResult
}
/**
 * Calibrate timing samples.
 *
 * # Arguments
 * - `baseline` - Baseline timing samples (raw ticks)
 * - `sample` - Sample class timing samples (raw ticks)
 * - `config` - Analysis configuration
 * - `timer_frequency_hz` - Timer frequency in Hz
 */
export declare function calibrateSamples(baseline: BigInt64Array, sample: BigInt64Array, config: Config, timerFrequencyHz: number): Calibration
/** Run one adaptive step with a new batch of samples. */
export declare function adaptiveStepBatch(calibration: Calibration, state: AdaptiveState, baseline: BigInt64Array, sample: BigInt64Array, config: Config, elapsedSecs: number): AdaptiveStepResult
/** Run complete analysis on pre-collected timing data. */
export declare function analyze(baseline: BigInt64Array, sample: BigInt64Array, config: Config, timerFrequencyHz: number): AnalysisResult
/** Attacker model determines the minimum effect threshold (theta) for leak detection. */
export const enum AttackerModel {
  /** theta = 0.6 ns (~2 cycles @ 3GHz) - SGX, cross-VM, containers */
  SharedHardware = 0,
  /** theta = 3.3 ns (~10 cycles) - Post-quantum crypto */
  PostQuantum = 1,
  /** theta = 100 ns - LAN, HTTP/2 (Timeless Timing Attacks) */
  AdjacentNetwork = 2,
  /** theta = 50 us - General internet */
  RemoteNetwork = 3,
  /** theta -> 0 - Detect any difference (not for CI) */
  Research = 4
}
/** Test outcome. */
export const enum Outcome {
  /** No timing leak detected within threshold theta. */
  Pass = 0,
  /** Timing leak detected exceeding threshold theta. */
  Fail = 1,
  /** Could not reach a decision. */
  Inconclusive = 2,
  /** Operation too fast to measure reliably. */
  Unmeasurable = 3
}
/** Reason for inconclusive result. */
export const enum InconclusiveReason {
  /** Not applicable (outcome is not Inconclusive). */
  None = 0,
  /** Posterior approximately equals prior after calibration. */
  DataTooNoisy = 1,
  /** Posterior stopped updating despite new data. */
  NotLearning = 2,
  /** Estimated time to decision exceeds budget. */
  WouldTakeTooLong = 3,
  /** Time budget exhausted. */
  TimeBudgetExceeded = 4,
  /** Sample limit reached. */
  SampleBudgetExceeded = 5,
  /** Measurement conditions changed during test. */
  ConditionsChanged = 6,
  /** Threshold was elevated due to measurement noise. */
  ThresholdElevated = 7
}
/** Pattern of timing effect. */
export const enum EffectPattern {
  /** Uniform shift across all quantiles. */
  UniformShift = 0,
  /** Effect concentrated in tails (upper quantiles). */
  TailEffect = 1,
  /** Both shift and tail components present. */
  Mixed = 2,
  /** Cannot determine pattern. */
  Indeterminate = 3
}
/** Exploitability assessment. */
export const enum Exploitability {
  /** < 10 ns - Requires shared hardware to exploit. */
  SharedHardwareOnly = 0,
  /** 10-100 ns - Exploitable via HTTP/2 request multiplexing. */
  Http2Multiplexing = 1,
  /** 100 ns - 10 us - Exploitable with standard remote timing. */
  StandardRemote = 2,
  /** > 10 us - Obvious leak, trivially exploitable. */
  ObviousLeak = 3
}
/** Measurement quality assessment. */
export const enum MeasurementQuality {
  /** MDE < 5 ns - Excellent measurement precision. */
  Excellent = 0,
  /** MDE 5-20 ns - Good precision. */
  Good = 1,
  /** MDE 20-100 ns - Poor precision. */
  Poor = 2,
  /** MDE > 100 ns - Too noisy for reliable detection. */
  TooNoisy = 3
}
/** Effect size estimate. */
export interface EffectEstimate {
  /** Uniform shift component in nanoseconds. */
  shiftNs: number
  /** Tail effect component in nanoseconds. */
  tailNs: number
  /** Lower bound of 95% credible interval for total effect. */
  credibleIntervalLow: number
  /** Upper bound of 95% credible interval for total effect. */
  credibleIntervalHigh: number
  /** Pattern of the effect. */
  pattern: EffectPattern
  /** Interpretation caveat if model fit is poor. */
  interpretationCaveat?: string
}
/** Diagnostics information for debugging and quality assessment. */
export interface Diagnostics {
  /** Block length used for bootstrap resampling. */
  dependenceLength: number
  /** Effective sample size accounting for autocorrelation. */
  effectiveSampleSize: number
  /** Ratio of post-test variance to calibration variance. */
  stationarityRatio: number
  /** Whether stationarity check passed. */
  stationarityOk: boolean
  /** Projection mismatch Q statistic. */
  projectionMismatchQ: number
  /** Whether projection mismatch is acceptable. */
  projectionMismatchOk: boolean
  /** Whether discrete mode was used (low timer resolution). */
  discreteMode: boolean
  /** Timer resolution in nanoseconds. */
  timerResolutionNs: number
  /** Posterior mean of latent scale lambda. */
  lambdaMean: number
  /** Whether lambda chain mixed well. */
  lambdaMixingOk: boolean
}
/** Configuration for the timing analysis. */
export interface Config {
  /** Attacker model to use (determines threshold theta). */
  attackerModel: AttackerModel
  /** Maximum samples per class. 0 = default (100,000). */
  maxSamples: number
  /** Time budget in milliseconds. 0 = default (30,000 ms). */
  timeBudgetMs: number
  /** Pass threshold for leak probability. Default: 0.05. */
  passThreshold: number
  /** Fail threshold for leak probability. Default: 0.95. */
  failThreshold: number
  /** Random seed. None = use system entropy. */
  seed?: number
  /** Custom threshold in nanoseconds (overrides attacker_model). */
  customThresholdNs?: number
}
/** Analysis result. */
export interface AnalysisResult {
  /** Test outcome. */
  outcome: Outcome
  /** Leak probability: P(max_k |(X*beta)_k| > theta | data). */
  leakProbability: number
  /** Effect size estimate. */
  effect: EffectEstimate
  /** Measurement quality. */
  quality: MeasurementQuality
  /** Number of samples used per class. */
  samplesUsed: number
  /** Time spent in seconds. */
  elapsedSecs: number
  /** Exploitability (only valid if outcome == Fail). */
  exploitability: Exploitability
  /** Inconclusive reason (only valid if outcome == Inconclusive). */
  inconclusiveReason: InconclusiveReason
  /** Minimum detectable effect (shift) in nanoseconds. */
  mdeShiftNs: number
  /** Minimum detectable effect (tail) in nanoseconds. */
  mdeTailNs: number
  /** Timer resolution in nanoseconds. */
  timerResolutionNs: number
  /** User's requested threshold (theta) in nanoseconds. */
  thetaUserNs: number
  /** Effective threshold after floor adjustment in nanoseconds. */
  thetaEffNs: number
  /** Recommendation string (empty if not applicable). */
  recommendation: string
  /** Detailed diagnostics. */
  diagnostics: Diagnostics
}
/** Timer calibration info. */
export interface TimerInfo {
  /** Cycles per nanosecond. */
  cyclesPerNs: number
  /** Timer resolution in nanoseconds. */
  resolutionNs: number
  /** Timer frequency in Hz. */
  frequencyHz: number
}
/**
 * Read the CPU cycle counter.
 *
 * This is a very fast operation (~1-2ns overhead) that reads:
 * - x86_64: `lfence; rdtsc` (CPU timestamp counter)
 * - aarch64: `isb; mrs cntvct_el0` (virtual timer count)
 *
 * Returns raw timer ticks as a BigInt. Use `calibrateTimer()` to convert to nanoseconds.
 *
 * # Example (TypeScript)
 * ```typescript
 * const start = rdtsc();
 * myOperation();
 * const elapsed = rdtsc() - start;
 * ```
 */
export declare function rdtsc(): number
/**
 * Get timer calibration information.
 *
 * Performs a quick calibration (~100ms) to determine:
 * - `cyclesPerNs` - Timer ticks per nanosecond
 * - `resolutionNs` - Timer resolution in nanoseconds
 * - `frequencyHz` - Timer frequency in Hz
 *
 * # Example (TypeScript)
 * ```typescript
 * const info = calibrateTimer();
 * const elapsedNs = Number(elapsed) / info.cyclesPerNs;
 * ```
 */
export declare function calibrateTimer(): TimerInfo
/** Get the library version. */
export declare function version(): string
/** Create a default configuration for a given attacker model. */
export declare function defaultConfig(attackerModel: AttackerModel): Config
/** Create a configuration for adjacent network attacker (100ns threshold). */
export declare function configAdjacentNetwork(): Config
/** Create a configuration for shared hardware attacker (0.6ns threshold). */
export declare function configSharedHardware(): Config
/** Create a configuration for remote network attacker (50us threshold). */
export declare function configRemoteNetwork(): Config
/** Opaque calibration state handle. */
export declare class Calibration { }
/** Adaptive sampling state. */
export declare class AdaptiveState {
  /** Create a new adaptive state. */
  constructor()
  /** Get total baseline samples collected. */
  get totalBaseline(): number
  /** Get total sample class samples collected. */
  get totalSample(): number
  /** Get current leak probability estimate. */
  get currentProbability(): number
  /** Get the number of batches collected so far. */
  get batchCount(): number
}
