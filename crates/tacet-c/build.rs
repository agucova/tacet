//! Build script for tacet-c
//!
//! Generates C header file using cbindgen.

use std::env;
use std::fs;
use std::path::PathBuf;

fn main() {
    let crate_dir = env::var("CARGO_MANIFEST_DIR").unwrap();
    let _package_name = env::var("CARGO_PKG_NAME").unwrap();

    // Create include directory if it doesn't exist
    let include_dir = PathBuf::from(&crate_dir).join("include");
    std::fs::create_dir_all(&include_dir).expect("Failed to create include directory");

    // Generate header using cbindgen
    let output_file = include_dir.join("tacet.h");

    let config = cbindgen::Config {
        language: cbindgen::Language::C,
        include_guard: Some("TACET_H".to_string()),
        pragma_once: false,
        cpp_compat: true,
        documentation: true,
        documentation_style: cbindgen::DocumentationStyle::Doxy,
        no_includes: true,
        includes: vec![
            "stdint.h".to_string(),
            "stddef.h".to_string(),
            "stdbool.h".to_string(),
        ],
        header: Some(
            "/**\n\
             * @file tacet.h\n\
             * @brief C API for tacet: Statistical timing side-channel detection\n\
             *\n\
             * This header is auto-generated by cbindgen. Do not edit manually.\n\
             *\n\
             * @section Usage\n\
             *\n\
             * ## One-Shot Analysis\n\
             * 1. Collect timing samples in your own measurement loop\n\
             * 2. Call to_analyze() with baseline and sample arrays\n\
             * 3. Check the result outcome\n\
             *\n\
             * ## Adaptive Sampling Loop\n\
             * 1. Collect calibration samples (5000 recommended)\n\
             * 2. Call to_calibrate() to get calibration data\n\
             * 3. Create state with to_state_new()\n\
             * 4. In a loop: collect batches, call to_step(), check for decision\n\
             * 5. Free resources with to_state_free() and to_calibration_free()\n\
             */\n"
                .to_string(),
        ),
        after_includes: None,
        trailer: None,
        ..Default::default()
    };

    cbindgen::Builder::new()
        .with_crate(&crate_dir)
        .with_config(config)
        .generate()
        .expect("Unable to generate C bindings")
        .write_to_file(&output_file);

    println!("cargo:rerun-if-changed=src/lib.rs");
    println!("cargo:rerun-if-changed=src/types.rs");
    println!("cargo:rustc-env=GENERATED_HEADER={}", output_file.display());

    // Generate pkg-config file
    generate_pkgconfig(&crate_dir);
}

/// Get platform-specific library flags for pkg-config
fn get_platform_libs() -> &'static str {
    let target_os = env::var("CARGO_CFG_TARGET_OS").unwrap_or_default();
    match target_os.as_str() {
        "macos" => "-framework Security -framework CoreFoundation",
        "linux" => "-lpthread -ldl -lm",
        _ => "",
    }
}

/// Substitute template variables in the pkg-config template
fn substitute_template(template: &str, version: &str, platform_libs: &str) -> String {
    template
        .replace("@PREFIX@", "/usr/local")
        .replace("@LIBDIR@", "/usr/local/lib")
        .replace("@INCLUDEDIR@", "/usr/local/include/tacet")
        .replace("@VERSION@", version)
        .replace("@PLATFORM_LIBS@", platform_libs)
}

/// Generate pkg-config file from template
fn generate_pkgconfig(crate_dir: &str) {
    let template_path = PathBuf::from(crate_dir).join("tacet.pc.in");
    let template = fs::read_to_string(&template_path)
        .expect("Failed to read tacet.pc.in template");

    let version = env::var("CARGO_PKG_VERSION").unwrap();
    let platform_libs = get_platform_libs();
    let pc_content = substitute_template(&template, &version, platform_libs);

    // Write to target directory (profile-specific: debug or release)
    // When cross-compiling, cargo sets TARGET and OUT_DIR points to target-specific dir
    let out_dir = env::var("OUT_DIR").unwrap();
    let profile = env::var("PROFILE").unwrap_or_else(|_| "debug".to_string());

    // OUT_DIR is like target/$rust_target/$profile/build/tacet-c-xxx/out
    // We need to write to target/$rust_target/$profile/tacet.pc
    let out_path = PathBuf::from(&out_dir);
    let target_dir = out_path
        .ancestors()
        .find(|p| p.ends_with(&profile))
        .expect("Could not find profile directory");

    let pc_file = target_dir.join("tacet.pc");
    fs::write(&pc_file, pc_content)
        .expect("Failed to write tacet.pc file");

    println!("cargo:rerun-if-changed=tacet.pc.in");
}
