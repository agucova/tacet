/**
* @file timing_oracle.h
* @brief C API for timing-oracle: Statistical timing side-channel detection
*
* This header is auto-generated by cbindgen. Do not edit manually.
*
* @section Usage
*
* ## One-Shot Analysis
* 1. Collect timing samples in your own measurement loop
* 2. Call to_analyze() with baseline and sample arrays
* 3. Check the result outcome
*
* ## Adaptive Sampling Loop
* 1. Collect calibration samples (5000 recommended)
* 2. Call to_calibrate() to get calibration data
* 3. Create state with to_state_new()
* 4. In a loop: collect batches, call to_step(), check for decision
* 5. Free resources with to_state_free() and to_calibration_free()
*/


#ifndef TIMING_ORACLE_H
#define TIMING_ORACLE_H

#include "stdint.h"
#include "stddef.h"
#include "stdbool.h"

/**
 * Attacker model presets defining the timing threshold (theta).
 */
typedef enum ToAttackerModel {
  /**
   * theta = 0.6 ns (~2 cycles @ 3GHz) - SGX, cross-VM, containers
   */
  SharedHardware = 0,
  /**
   * theta = 3.3 ns (~10 cycles) - Post-quantum crypto
   */
  PostQuantum = 1,
  /**
   * theta = 100 ns - LAN, HTTP/2 (Timeless Timing Attacks)
   */
  AdjacentNetwork = 2,
  /**
   * theta = 50 us - General internet
   */
  RemoteNetwork = 3,
  /**
   * theta -> 0 - Detect any difference (not for CI)
   */
  Research = 4,
} ToAttackerModel;

/**
 * Error codes.
 */
typedef enum ToError {
  /**
   * No error.
   */
  Ok = 0,
  /**
   * Null pointer passed.
   */
  NullPointer = 1,
  /**
   * Invalid configuration.
   */
  InvalidConfig = 2,
  /**
   * Calibration failed.
   */
  CalibrationFailed = 3,
  /**
   * Analysis failed.
   */
  AnalysisFailed = 4,
  /**
   * Not enough samples.
   */
  NotEnoughSamples = 5,
} ToError;

/**
 * Test outcome.
 */
typedef enum ToOutcome {
  /**
   * No timing leak detected within the threshold.
   */
  Pass = 0,
  /**
   * Timing leak detected exceeding the threshold.
   */
  Fail = 1,
  /**
   * Could not reach a decision within budget.
   */
  Inconclusive = 2,
  /**
   * Operation too fast to measure reliably.
   */
  Unmeasurable = 3,
} ToOutcome;

/**
 * Effect pattern.
 */
typedef enum ToEffectPattern {
  /**
   * Constant timing difference across all quantiles.
   */
  UniformShift = 0,
  /**
   * Timing difference concentrated in upper quantiles.
   */
  TailEffect = 1,
  /**
   * Both shift and tail components present.
   */
  Mixed = 2,
  /**
   * Pattern cannot be determined.
   */
  Indeterminate = 3,
} ToEffectPattern;

/**
 * Measurement quality assessment.
 */
typedef enum ToMeasurementQuality {
  /**
   * MDE < 5 ns - Excellent precision.
   */
  Excellent = 0,
  /**
   * MDE 5-20 ns - Good for most use cases.
   */
  Good = 1,
  /**
   * MDE 20-100 ns - Limited precision.
   */
  Poor = 2,
  /**
   * MDE > 100 ns - Too noisy for reliable detection.
   */
  TooNoisy = 3,
} ToMeasurementQuality;

/**
 * Exploitability assessment.
 */
typedef enum ToExploitability {
  /**
   * < 10 ns - Requires shared hardware to exploit.
   */
  SharedHardwareOnly = 0,
  /**
   * 10-100 ns - Exploitable via HTTP/2 multiplexing.
   */
  Http2Multiplexing = 1,
  /**
   * 100 ns - 10 us - Exploitable with standard remote timing.
   */
  StandardRemote = 2,
  /**
   * > 10 us - Obvious leak, trivially exploitable.
   */
  ObviousLeak = 3,
} ToExploitability;

/**
 * Reason for inconclusive result.
 */
typedef enum ToInconclusiveReason {
  None = 0,
  DataTooNoisy = 1,
  NotLearning = 2,
  WouldTakeTooLong = 3,
  TimeBudgetExceeded = 4,
  SampleBudgetExceeded = 5,
  ConditionsChanged = 6,
  ThresholdElevated = 7,
} ToInconclusiveReason;

/**
 * Opaque handle to calibration data.
 * Created by `to_calibrate()`, freed by `to_calibration_free()`.
 */
typedef struct ToCalibration ToCalibration;

/**
 * Opaque handle to adaptive state.
 * Created by `to_state_new()`, freed by `to_state_free()`.
 */
typedef struct ToState ToState;

/**
 * Configuration for timing analysis.
 */
typedef struct ToConfig {
  /**
   * Attacker model (determines threshold theta).
   */
  enum ToAttackerModel attacker_model;
  /**
   * Custom threshold in nanoseconds (only if attacker_model would be Custom).
   * Set to 0.0 to use the attacker model's default threshold.
   */
  double custom_threshold_ns;
  /**
   * Maximum samples per class. 0 = default (100,000).
   */
  uint64_t max_samples;
  /**
   * Time budget in seconds. 0 = default (30s).
   */
  double time_budget_secs;
  /**
   * Pass threshold for P(leak). Default: 0.05.
   */
  double pass_threshold;
  /**
   * Fail threshold for P(leak). Default: 0.95.
   */
  double fail_threshold;
  /**
   * Random seed. 0 = use default seed.
   */
  uint64_t seed;
  /**
   * Timer frequency in Hz (for converting ticks to nanoseconds).
   * 0 = assume 1 tick = 1 ns.
   */
  uint64_t timer_frequency_hz;
} ToConfig;

/**
 * Effect size estimate.
 */
typedef struct ToEffect {
  /**
   * Uniform shift component in nanoseconds.
   */
  double shift_ns;
  /**
   * Tail effect component in nanoseconds.
   */
  double tail_ns;
  /**
   * 95% credible interval lower bound.
   */
  double ci_low_ns;
  /**
   * 95% credible interval upper bound.
   */
  double ci_high_ns;
  /**
   * Effect pattern.
   */
  enum ToEffectPattern pattern;
} ToEffect;

/**
 * Complete analysis result.
 */
typedef struct ToResult {
  /**
   * Test outcome.
   */
  enum ToOutcome outcome;
  /**
   * Leak probability: P(max effect > theta | data).
   */
  double leak_probability;
  /**
   * Effect size estimate.
   */
  struct ToEffect effect;
  /**
   * Measurement quality.
   */
  enum ToMeasurementQuality quality;
  /**
   * Number of samples used per class.
   */
  uint64_t samples_used;
  /**
   * Elapsed time in seconds.
   */
  double elapsed_secs;
  /**
   * Exploitability (only meaningful if outcome == Fail).
   */
  enum ToExploitability exploitability;
  /**
   * Inconclusive reason (only meaningful if outcome == Inconclusive).
   */
  enum ToInconclusiveReason inconclusive_reason;
  /**
   * Minimum detectable effect (shift) in nanoseconds.
   */
  double mde_shift_ns;
  /**
   * Minimum detectable effect (tail) in nanoseconds.
   */
  double mde_tail_ns;
  /**
   * User's requested threshold in nanoseconds.
   */
  double theta_user_ns;
  /**
   * Effective threshold after floor adjustment.
   */
  double theta_eff_ns;
  /**
   * Measurement floor in nanoseconds.
   */
  double theta_floor_ns;
} ToResult;

/**
 * Result of an adaptive step.
 */
typedef struct ToStepResult {
  /**
   * Whether a decision was reached.
   */
  bool has_decision;
  /**
   * Current leak probability estimate.
   */
  double leak_probability;
  /**
   * Number of samples used so far.
   */
  uint64_t samples_used;
  /**
   * Elapsed time in seconds (only set when has_decision is true).
   */
  double elapsed_secs;
  /**
   * The result (only valid if has_decision is true).
   */
  struct ToResult result;
} ToStepResult;

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

/**
 * Create a default configuration for the given attacker model.
 */
struct ToConfig to_config_default(enum ToAttackerModel attacker_model);

/**
 * Create a configuration for SharedHardware attacker model.
 */
struct ToConfig to_config_shared_hardware(void);

/**
 * Create a configuration for AdjacentNetwork attacker model.
 */
struct ToConfig to_config_adjacent_network(void);

/**
 * Create a configuration for RemoteNetwork attacker model.
 */
struct ToConfig to_config_remote_network(void);

/**
 * Create a new adaptive state for tracking the measurement loop.
 *
 * Must be freed with `to_state_free()`.
 *
 * # Returns
 * Pointer to new state, or NULL on allocation failure.
 */
struct ToState *to_state_new(void);

/**
 * Free an adaptive state.
 *
 * # Safety
 * `state` must be a valid pointer returned by `to_state_new()`, or NULL.
 */
void to_state_free(struct ToState *state);

/**
 * Get the total number of samples collected (both classes combined).
 *
 * # Safety
 * `state` must be a valid pointer.
 */
uint64_t to_state_total_samples(const struct ToState *state);

/**
 * Get the current leak probability estimate.
 *
 * Returns 0.5 if no posterior has been computed yet.
 *
 * # Safety
 * `state` must be a valid pointer.
 */
double to_state_leak_probability(const struct ToState *state);

/**
 * Run calibration on initial samples.
 *
 * This should be called once at the start with calibration samples
 * (typically 5000 per class). The returned calibration handle is used
 * for subsequent `to_step()` calls.
 *
 * # Parameters
 * - `baseline`: Array of baseline timing samples (in timer ticks)
 * - `sample`: Array of sample timing samples (in timer ticks)
 * - `count`: Number of samples in each array
 * - `config`: Configuration
 * - `error_out`: Optional pointer to receive error code
 *
 * # Returns
 * Pointer to calibration data, or NULL on error.
 * Must be freed with `to_calibration_free()`.
 *
 * # Safety
 * `baseline` and `sample` must be valid pointers to arrays of at least `count` elements.
 */
struct ToCalibration *to_calibrate(const uint64_t *baseline,
                                   const uint64_t *sample,
                                   uintptr_t count,
                                   const struct ToConfig *config,
                                   enum ToError *error_out);

/**
 * Free calibration data.
 *
 * # Safety
 * `calibration` must be a valid pointer returned by `to_calibrate()`, or NULL.
 */
void to_calibration_free(struct ToCalibration *calibration);

/**
 * Run one adaptive step with a batch of new samples.
 *
 * Call this in a loop after `to_calibrate()`. Each call processes a batch
 * of new timing samples and updates the posterior probability.
 *
 * # Parameters
 * - `calibration`: Calibration data from `to_calibrate()`
 * - `state`: Adaptive state from `to_state_new()`
 * - `baseline`: Array of new baseline timing samples (in timer ticks)
 * - `sample`: Array of new sample timing samples (in timer ticks)
 * - `count`: Number of samples in each array
 * - `config`: Configuration
 * - `elapsed_secs`: Total elapsed time since start
 * - `result_out`: Pointer to receive the step result
 *
 * # Returns
 * Error code.
 *
 * # Safety
 * All pointers must be valid.
 */
enum ToError to_step(const struct ToCalibration *calibration,
                     struct ToState *state,
                     const uint64_t *baseline,
                     const uint64_t *sample,
                     uintptr_t count,
                     const struct ToConfig *config,
                     double elapsed_secs,
                     struct ToStepResult *result_out);

/**
 * Analyze pre-collected timing samples.
 *
 * This is a convenience function for one-shot analysis when you already
 * have timing data collected. For a C measurement loop, use
 * `to_calibrate()` + `to_step()` instead.
 *
 * # Parameters
 * - `baseline`: Array of baseline timing samples (in timer ticks)
 * - `sample`: Array of sample timing samples (in timer ticks)
 * - `count`: Number of samples in each array
 * - `config`: Configuration
 * - `result_out`: Pointer to receive the result
 *
 * # Returns
 * Error code.
 *
 * # Safety
 * All pointers must be valid.
 */
enum ToError to_analyze(const uint64_t *baseline,
                        const uint64_t *sample,
                        uintptr_t count,
                        const struct ToConfig *config,
                        struct ToResult *result_out);

/**
 * Get the library version string.
 *
 * # Returns
 * Pointer to a static null-terminated string.
 */
const char *to_version(void);

/**
 * Get attacker model threshold in nanoseconds.
 */
double to_attacker_threshold_ns(enum ToAttackerModel model);

#ifdef __cplusplus
}  // extern "C"
#endif  // __cplusplus

#endif  /* TIMING_ORACLE_H */
