---
title: Testing Patterns
description: Practical patterns for testing cryptographic code with timing-oracle
sidebar:
  order: 2
---

import { Aside, Tabs, TabItem } from '@astrojs/starlight/components';

Practical, copy-pasteable testing patterns for using timing-oracle in real-world scenarios.

## Basic Patterns

### Simplest Constant-Time Test

Verify that a simple operation (like XOR or array copy) is constant-time.

```rust
use timing_oracle::{TimingOracle, AttackerModel, helpers::InputPair};

let inputs = InputPair::new(
    || [0x00u8; 64],  // Baseline: all zeros
    || [0xFFu8; 64],  // Sample: all ones
);

let outcome = TimingOracle::for_attacker(AttackerModel::AdjacentNetwork)
    .max_samples(30_000)
    .test(inputs, |data| {
        let result = data.iter().fold(0u8, |acc, &b| acc ^ b);
        std::hint::black_box(result);  // Prevent compiler optimizations
    });

assert!(outcome.passed(), "XOR should be constant-time");
```

**Key points:**
- `black_box()` prevents compiler from optimizing away the operation
- Both inputs go through identical code path
- Only the DATA differs (0x00 vs 0xFF)

### DudeCT Two-Class Pattern (Fixed vs Random)

Standard pattern for testing secret-dependent operations.

```rust
use timing_oracle::{TimingOracle, AttackerModel, Outcome, helpers::InputPair};

let secret = [0xABu8; 32];

let inputs = InputPair::new(
    || [0xABu8; 32],              // Baseline: matches secret (slow path)
    || rand::random::<[u8; 32]>(), // Sample: random data (fast path)
);

let outcome = TimingOracle::for_attacker(AttackerModel::AdjacentNetwork)
    .test(inputs, |data| {
        // Test if compare function has early-exit leak
        compare_function(&secret, &data);
    });

match outcome {
    Outcome::Pass { .. } => println!("Constant-time"),
    Outcome::Fail { exploitability, .. } => panic!("Leak: {:?}", exploitability),
    _ => {}
}
```

<Aside type="caution" title="Baseline must match the secret">
For comparison functions, baseline must MATCH the secret to create timing asymmetry. If the secret were different, both inputs would exit early on the first byte.
</Aside>

---

## Input Generation Patterns

### Rule: Closures Not Values

```rust
// ❌ WRONG: Captured value - same value for ALL measurements
let random_value = rand::random::<[u8; 32]>();
let inputs = InputPair::new(
    || [0u8; 32],
    || random_value,  // Always returns the same value!
);

// ✓ CORRECT: Fresh generation each call
let inputs = InputPair::new(
    || [0u8; 32],
    || rand::random::<[u8; 32]>(),  // New value each time
);
```

### Pattern: Thread-Safe Counters for Unique Values

```rust
use std::sync::atomic::{AtomicU64, Ordering};

let counter = AtomicU64::new(0);

let inputs = InputPair::new(
    || [0u8; 32],
    || {
        let i = counter.fetch_add(1, Ordering::Relaxed);
        let mut data = [0u8; 32];
        data[0..8].copy_from_slice(&i.to_le_bytes());
        data
    },
);
```

---

## Crypto-Specific Patterns

### AEAD Ciphers (AES-GCM, ChaCha20-Poly1305)

<Aside type="danger" title="Critical: Nonce Handling">
AEAD ciphers require unique nonces. Reusing nonces can break the cipher AND create false positive timing results!
</Aside>

```rust
use chacha20poly1305::{ChaCha20Poly1305, KeyInit, AeadInPlace, Nonce};
use std::sync::atomic::{AtomicU64, Ordering};

let key = ChaCha20Poly1305::generate_key(&mut rand::thread_rng());
let cipher = ChaCha20Poly1305::new(&key);
let nonce_counter = AtomicU64::new(0);

let inputs = InputPair::new(
    || [0u8; 64],
    || rand::random::<[u8; 64]>(),
);

let outcome = TimingOracle::for_attacker(AttackerModel::AdjacentNetwork)
    .test(inputs, |plaintext| {
        // Generate unique nonce for each measurement
        let nonce_val = nonce_counter.fetch_add(1, Ordering::Relaxed);
        let mut nonce_bytes = [0u8; 12];
        nonce_bytes[0..8].copy_from_slice(&nonce_val.to_le_bytes());
        let nonce = Nonce::from_slice(&nonce_bytes);

        let mut buffer = plaintext.to_vec();
        cipher.encrypt_in_place(nonce, b"", &mut buffer).unwrap();
    });
```

### Block Ciphers (AES)

```rust
use aes::cipher::{BlockEncrypt, KeyInit, generic_array::GenericArray};
use aes::Aes128;

let key = GenericArray::from([0x42u8; 16]);
let cipher = Aes128::new(&key);

let inputs = InputPair::new(
    || [0u8; 16],
    || rand::random::<[u8; 16]>(),
);

let outcome = TimingOracle::for_attacker(AttackerModel::AdjacentNetwork)
    .test(inputs, |plaintext| {
        let mut block = GenericArray::clone_from_slice(plaintext);
        cipher.encrypt_block(&mut block);
        std::hint::black_box(block);
    });
```

### Hash Functions

```rust
use sha3::{Sha3_256, Digest};

let inputs = InputPair::new(
    || [0u8; 64],
    || rand::random::<[u8; 64]>(),
);

let outcome = TimingOracle::for_attacker(AttackerModel::AdjacentNetwork)
    .test(inputs, |data| {
        let mut hasher = Sha3_256::new();
        hasher.update(data);
        std::hint::black_box(hasher.finalize());
    });
```

### Elliptic Curve (X25519)

```rust
use x25519_dalek::{StaticSecret, PublicKey};

let secret = StaticSecret::random_from_rng(&mut rand::thread_rng());

let inputs = InputPair::new(
    || [0u8; 32],
    || rand::random::<[u8; 32]>(),
);

let outcome = TimingOracle::for_attacker(AttackerModel::AdjacentNetwork)
    .test(inputs, |scalar_bytes| {
        let public = PublicKey::from(scalar_bytes);
        let shared = secret.diffie_hellman(&public);
        std::hint::black_box(shared);
    });
```

---

## Advanced Patterns

### Testing Async Code

```rust
use tokio::runtime::Runtime;

let rt = Runtime::new().unwrap();

let inputs = InputPair::new(
    || [0u8; 32],
    || rand::random::<[u8; 32]>(),
);

let outcome = TimingOracle::for_attacker(AttackerModel::AdjacentNetwork)
    .test(inputs, |data| {
        rt.block_on(async {
            async_crypto_operation(&data).await;
        })
    });
```

<Aside type="tip">
Use single-threaded runtime (`new_current_thread()`) for lower noise.
</Aside>

### Testing with Pre-initialized State

```rust
use std::sync::Arc;

// Setup expensive state once
let state = Arc::new(ExpensiveSetup::new());

let inputs = InputPair::new(
    || [0u8; 32],
    || rand::random::<[u8; 32]>(),
);

let outcome = TimingOracle::for_attacker(AttackerModel::AdjacentNetwork)
    .test(inputs, |data| {
        // State is pre-initialized, not created per-measurement
        state.process(&data);
    });
```

---

## CI Integration

### Basic CI Test

```rust
#[test]
fn test_constant_time() {
    let inputs = InputPair::new(
        || [0u8; 32],
        || rand::random::<[u8; 32]>(),
    );

    let outcome = TimingOracle::for_attacker(AttackerModel::AdjacentNetwork)
        .time_budget(Duration::from_secs(30))
        .test(inputs, |data| my_crypto_op(&data));

    match outcome {
        Outcome::Pass { .. } => {}
        Outcome::Fail { .. } => panic!("Timing leak detected!"),
        Outcome::Inconclusive { .. } => {
            // Optionally skip or warn in noisy CI
        }
        Outcome::Unmeasurable { .. } => {
            // Skip if operation too fast
        }
    }
}
```

### Handling Noisy CI Environments

```rust
use timing_oracle::skip_if_unreliable;

#[test]
fn test_with_reliability_check() {
    let inputs = InputPair::new(|| [0u8; 32], || rand::random());
    let outcome = TimingOracle::for_attacker(AttackerModel::AdjacentNetwork)
        .test(inputs, |data| my_op(&data));

    // Skip test if environment is too noisy
    let outcome = skip_if_unreliable!(outcome, "test_name");
    assert!(outcome.passed());
}
```

---

## Common Mistakes Checklist

| Mistake | Fix |
|---------|-----|
| Captured value in closure | Use `|| rand::random()` not `|| captured_value` |
| Same nonce for AEAD | Use atomic counter for unique nonces |
| Baseline doesn't match secret | For comparisons, baseline must equal the secret |
| Missing `black_box()` | Wrap results to prevent optimization |
| Generator allocates memory | Pre-allocate buffers outside measurement |
| Testing in VM | Run on bare metal for reliable results |

---

## Quick Reference

| Pattern | Use When |
|---------|----------|
| Zeros vs Random | Most crypto operations |
| Match Secret vs Random | Comparison functions |
| Pool cycling | Need deterministic samples |
| Atomic nonce counter | AEAD encryption |
| `skip_if_unreliable!` | Noisy CI environments |
